# 10장 단위 테스트의 원칙  

> "딱 한줄 고쳤는데요?" .. 코드 변경은 언제나 위험하기 때문에 <br/>
코드가 의도한 대로 작동한다는 것을 스스로 확인할 수 있는 방법이 필요하다.  

## 이 장에서 다루는 내용  
- 단위 테스트의 기본 사항
- 좋은 단위 테스트가 되기 위한 조건
- 테스트 더블
- 테스트 철학  

#### `단위 테스트에 대한 정확한 정의는 없다.`
   >  해당 파트의 초입 부분에 언급된 문장입니다.
   >  개인적인 생각으로는 <br/> 팀 단위 개발 환경의 차이와 
   >  정의된 함수에 디펜던시한 부분들 때문에 다를 수 밖에 없을 것이다라고 생각된다.

그렇기 때문에 단위 테스트를 어떻게 구성하고 , <br/>그 정의에 정확하게 부합하는지에 대해 너무 집착하지 않는 편이 좋을 것이다.  

## 10.1 단위 테스트 기초  

* `테스트 중인 코드(code under test)`: 실제 코드 라고도 하고 테스트의 대상이 되는 코드를 의미한다.
  
* `테스트 코드(test code)`: 단위 테스트를 구성하는 코드를 가리킨다.
  
* `테스트 케이스(test case)`: 테스트 코드의 각 파일에는 일반적으로 여러 테스트 케이스가 있고, <br/> 각 테스트 케이스는 특정 동작이나 시나리오를 테스트하며, 단순한 케이스가 아니라면 아래와 같이 세 가지 섹션으로 분류된다.
  * 준비(arrange): 테스트할 특정 동작을 호출하려면 먼저 몇 가지 설정을 수행해야 하는 경우가 많다. <br/>
    > 의존성 /인스턴스 설정 , 필요에 의한 인자값 셋팅
  * 실행(start): 테스트 중인 동작을 실제로 호출하는 코드를 나타낸다.
  * 단언(assert): 테스트 중인 동작이 실행되고 나면 실제로 올바른 일이 발생했는지 확인한다.
    
    > 실무에서는 given / when / then 이라는 표현을 많이 사용합니다.
    > 
* `테스트러너(test runner)`: 이름에서 알 수 있듯이 테스트 러너는 실제로 테스트를 실행하는 도구다.

테스트 코드의 중요성은 다른 책들을 봐도 쉽게 알 수 있듯이 ,  

요즘 대부분의 웹 및 앱 , 전문적인 소프트웨어 개발 환경에서는 거의 모든 실제 코드에 단위 테스트가 동반 될 것이다.  

훌룡한 테스트를 하기 위해서는 테스트만 있다고 되는 것이 아니라, 좋은 테스트가 필요하다.

## 10.2 좋은 단위 테스트는 어떻게 작성할 수 있는가?  

> 개인적으로 이상적인 테스트 코드에 시간을 낭비하지말고 <br/> 아래 정의된 단위 테스트가 가져야 할 5가지 주요 기능을 준수하는 것에 목적을 두는 것이 좋을 것 같다.

- `훼손의 정확한 감지`: 코드가 실제 훼손되거나 훼손된 경우에만 되면 테스트가 실패한다.  

- `세부 구현 사항에 독립적`: 세부 구현 사항을 변경하더라도 테스트 코드는 변경하지 않는 것이 이상적이다.  

- `잘 설명되는 실패`: 코드가 잘못되면 테스트는 실패의 원인과 문제점을 명확하게 설명해야 한다.  

- `이해할 수 있는 테스트 코드`: 다른 개발자들이 테스트 코드가 정확히 무엇을 테스트하는지 이해할 수 있어야한다.

- `쉽고 빠르게 실행`: 단위 테스트가 느리거나 실행이 어려우면 개발 시간이 낭비된다.

### 10.2.1 훼손의 정확한 감지  

단위 테스트의 가장 명확하고 주된 목표는 코드가 훼손되지 않았는지 확인하는 것이며,  

테스트 대상이 의도된 대로 수행되며 버그가 없다는 것을 확인하는 것이다.  

테스트 중인 코드가 어떤 식으로든 훼손되면 컴파일되지 않거나 테스트가 실패해야 한다.  

이것은 매우 중요한 두 가지 역할을 수행한다.

- `코드에 대한 초기 신뢰를 준다`

아무리 신중하게 코드를 작성해도 실수는 있기 마련이다.  

새로운 코드나 코드 변경 사항과 함께 철저한 테스트 코드를 작성하면 코드가 <br/>코드베이스로 병합되기 전에 이러한 실수를 발견하고 수정할 수 있다.  

- `미래의 훼손을 막아준다 `

어느 시점에 다른 개발자가 코드를 변경또는 병합하는 과정에서 실수로 코드를 훼손할 가능성이 크다.  

이것에 대한 유일한 효과적인 방어 방법은 코드가 컴파일을 중지하거나 테스트가 실패하는 것이다.  

어떤 것이 고장 났을 때 코드가 컴파일을 멈추도록 하는 것은 불가능하므로 <br/>모든 올바른 동작을 테스트를 통해 확인하는 것은 절대적으로 중요하다.  

코드 변경으로 인해 잘 돌아가던 기능이 동작하지 않는 것을 **회귀**라고 한다.  

이러한 회귀를 탐지할 목적으로 테스트를 실행하는 것을 **회귀 테스트**라고 한다.  

정확성의 또 다른 측면을 고려하는 것도 중요하다.  

`테스트 대상 코드가 실제로 훼손된 경우에만 테스트가 실패해야 한다.`  

위의 내용처럼 당연히 그렇게 될 것 같지만 실제로는 그렇지 않은 경우가 많다.  

논리적 오류를 경험한 사람이라면 누구나 알겠지만, <br/>`코드가 훼손되면 반드시 실패한다`는 것이 반드시 `코드가 훼손될 때만 테스트가 실패한다`는 것을 의미하는 것은 아니다.  

테스트 대상 코드가 정상임에도 불구하고 때로는 통과하고 때로는 실패하는 테스트를 플래키(flakey)라고한다.

이것은 보통 무작위 성, 타이밍 기반 레이스조건, 외부 시스템에 의존하는 등의 테스트의 비결정적동작에 기인한다.  

플래키테스트의 위험성을 피하기 위해선 코드에서 어떤 부분이 훼손될 때, <br/> 그리고 오직 훼손된 경우에만 테스트가 실패하도록 하는 것은 매우 중요하다.  

### 10.2.2 세부 구현 사항에 독립적

일반적으로 개발자가 코드베이스에 가할 수 있는 변경은 두 가지 종류가 있다.  

* `기능적 변화`: 코드가 외부로 보이는 동작을 수행하는 것을 의미하며. 새로운 기능 추가, 버그 수정, 에러 처리등이 있다.
* `리팩토링`: 큰 함수를 작은 함수로 분할하거나 재사용하기 쉽도록 코드의 구조적 변화를 의미한다.  

첫 번째(기능적변화) 는 동작의 변경을 의미하며 ,
두 번째(리팩토링) 경우는 코드를 사용하는 사람에게 영향을 미치지 않아야 한다.

하지만 코드의 구조만 변경하는 것인데 그 과정에서 실수로 코드의 동작을 변경하지 않았다고 확신할 수 있을까? 

해당 질문에 대한 답을 얻기 위해 리팩토링 전 단위테스트를 작성할 때, 아래 두 가지 접근 방식을 고려해보자.

접근방식 A : 테스트는 모든 동작을 확인하며 구현 세부 사항도 확인한다. <br/> 
프라이빗함수 및 멤버에 대한 접근 제어 변경, 의존성을 직접 조작하여 시뮬레이션 하며 검증하도록한다.

접근방식 B : 동작만 테스트한다. 구현 세부 사항은 확인하지 않는다.

시간이 흐른 뒤 리팩토링 시, 단위 테스트를 동작하여 실패한다면 그 원인은 오로지 리팩토링한 부분에만 있어야한다.

접근 방식 A 같은 경우 구현 세부사항 까지 고려해야하기 때문에 코드의 어느 부분이 실패가 되었는지 예상하기 어려우며,<br/>
접근 방식 B 같은 경우 리팩토링한 부분에 대해서만 고려하면 되는 것이다.

코드는 자주 리팩토링 되며, 접근 방식 A 와 같은 상황을 피하기 위해 구현 세부 사항에 의존하지 않는 것이 좋다.


### 10.2.3 잘 설명되는 실패  

테스트에 대한 실패가 발생했을 땐 실패가 발생되는 부분을 알아야한다.  

하지만 테스트 실패가 무엇이 잘못됐는지 알려주지 않는다면 그것을 알아내기 위한 많은 시간을 낭비한다.  

테스트 실패가 잘 설명되도록 하는 좋은 방법 중 하나는 하나의 테스트 케이스는 한 가지 사항만 검사하고, <br/>
각 테스트 케이스에 대해 서술적인 이름을 사용하는 것이다.  

### 10.2.4 이해 가능한 테스트 코드  

다른 개발자는 새로운 요구 사항을 충족하기 위해 코드의 기능을 의도적으로 수정할 수 있다.  

이러한 경우는 의도적이며, 변경을 수행하는 개발자는 변경된 결과가 안전한지 확인한 후에는<br/> 새로운 기능을 반영하기 위헤 테스트 코드도 수정해야 한다.  

개발자가 자신이 변경한 사항이 원하는 동작에만 영향을 미친다는 확신을 가지려면 테스트의 어느 부분이 영향을 미치고 있는지, <br/>테스트 코드에 대한 수정이 필요한지 여부를 알 수 있어야 한다.

이를 위해서는 서로 다른 테스트 케이스가 무엇을 테스트하는지 그리고 어떻게 테스트하는지 이해하고 있어야 한다.  

개발들이 테스트 코드를 일종의 사용설명서처럼 사용하기 때문에 이해 가능하게 작성해야 한다.  

### 10.2.5 쉽고 빠른 실행  

단위 테스트의 중요한 기능 중 하나는 잘못된 코드가 코드베이스에 병합되는 것을 방지하는 것이다.  

따라서 많은 코드베이스에서 관련 테스트를 통괴해야만 병합이 가능한 `병합 전 검사`를 수행한다.  

만약 단위 테스트를 실행하는 데 한 시간이 걸린다면 코드 변경 병합 요청이 작거나 사소한 것과 상관없이<br/> 최소 한 시간이 걸리기 때문에 모든 개발자의 속도가 느려진다.  

## 10.3 퍼블릭 API에 집중하되 중요한 동작은 무시하지 말라  

앞서 구현 세부사항에 구애받지 않는 것이 중요한 이유에 대해 설명했다.  

코드는 퍼블릭 API와 구현 세부 사항으로 나눌 수 있다.  

따라서 우리는 퍼블릭 API만을 사용해서 테스트해야 한다는 것을 의미한다.  

퍼블릭 API에 초점을 맞추면 세부 구현사항이 아닌 코드 사용자가 기대한 결과값에 대한 정상 동작 유무만 확인하면 되는 것이고, 

실제로 중요한 사항만 테스트 하는 데 도움이 되며, 테스트 과정에서 구현 세부 사항에 상관없이 테스트에 집중할 수 있다.  

### 10.3.1 중요한 동작이 퍼블릭 API 외부에 있을 수 있다  

말 그대로이다.  

테스트는 가능하다면 퍼블릭 API를 사용해서만 테스트하는 것을 목표로 해야한다.  

하지만 원하는 부수효과를 확인하기 위해서 테스트가 공용 API 의 일부가 아닌 종속성과 상호작용해야 하는 경우가 많다.  

서버와 상호작용하는 코드 , 데이터베이스에 값을 저장하거나 읽는 코드 등 이 있을 것이다.

위와 같이 다른 대안이 없는 경우에는 퍼블릭 API를 벗어나 테스트를 해야하지만,<br/> 
그럼에도 테스트는 최대한 구현 세부사항과 독릭접으로 수행할수 있도록 주의를 기울여야 한다.

## 10.4 테스트 더블  

의존성을 실제로 사용하는 것에 대안으로 테스트 더블(test double)이 있다.  

테스트 더블은 의존성을 시뮬레이션하는 객체지만 테스트에 더 적합하게 사용할 수 있도록 만들어진다.  

세가지 유형의 테스트 더블 목, 스텁, 페이크에 대해 살펴본다.  

### 10.4.1 테스트 더블을 사용하는 이유

* `테스트 단순화`

일부 의존성은 테스트에 사용하기 까다롭고 힘들다.  

의존성은 많은 설정이 필요하거나 하위 의존성을 설정해야 할 수도 있다.  

이러면 테스트는 복잡하고 구현 세부 사항과 밀집하게 결합될 수 있다.  

의존성을 실제로 사용하는 대신 테스트 더블을 사용하면 작업이 단순해진다.  

* `테스트로부터 외부 세계 보호`  

일부 의존성은 실제로 부수 효과를 발생한다.  

코드의 종속성 중 하나가 실제 서버에 요청을 전송하거나 실제 데이터베이스에 값을 쓰게 되면, 사용자가 비지니스에 중요한 프로세스에 나쁜 결과를 초래할 수 있다.  

이러한 상황에서 테스트 더블을 사용하면 외부 세계에 있는 시스템을 테스트의 동작으로부터 보호할 수 있다.  

* `외부로부터 테스트 보호`

외부 세계는 비결정적일 수 있다.  

다른 시스템이 데이터베이스에 쓴 값을 의존성 코드가 읽는다면 이 값은 시간이 지남에 따라 변경될 수 있다.  

이 경우 테스트 결과를 신뢰하기 어려울 수 있다.  

반면 테스트 더블은 항상 동일하게 결정적 방식으로 작동하도록 설정할 수 있다.  

### 10.4.2 목  

목(mock)은 클래스나 인터페이스를 시뮬레이션하는 데 멤버 함수에 대한 호출을 기록하는 것외에는 어떠한 일도 수행하지 않으며.  

함수가 호출될 때 인수에 제공되는 값을 기록한다.  

테스트 대상 코드가 의존성을 통해 제공되는 함수를 호출하는지 검증하기 위해 목을 사용할 수 있습니다.

아래는 예제 코드 입니다.  


```java
  class PaymentManager {
      // BankAccount 의 인스턴스를 인자로 받는다. 
      PaymentResult settleInvoice(BankAccount customerBankAccount, Invoice invoice) {
          customerBankAccount.debit(invoice.getBalance()); // 계좌로부터 청구서의 잔액만큼 인출하는 것을 테스트 하는 동작
          return PaymentResult.paid(invoice.getId());
      }
  }
```

실제 BankAccount 의 구현체에는 은행계좌에 잔액에 영향을 미치는 의존성이 있을 것이다.

debit() 함수가 올바른 인수로 호출되는지 확인하기 위해 아래와 같이 목 객체를 만들어 테스트할 수 있다.

```java
  void testSettleInvoice_accountDebited() {
      BankAccout mockAccount = createMock(BankAccount); // BankAccount 의 목 객체 생성
      ...생략
      new PaymentManager().settleInvoice(mockAccount,invoice); // mockAccount를 인수로 해서 호출

      verifyThat(mockAccount.debit)
         .wasCalledOnce()
         .withArguments(invoiceBalance); // mockAccount.debit() 함수가 예상한 인수로 호출되는지 확인
  }
```

위와 같이 테스트로부터 외부세계를 보호하긴 했지만, 

10.4.4 절에서 확인하겠지만 중요한 버그를 잡지 못할 위험이 있다.


### 10.4.3 스텁  

스텁은 함수가 호출되면 미리 정해 놓은 값을 반환함으로써 함수를 시뮬레이션 한다.  

이를 통해 테스트 대상 코드는 특정 멤버 함수를 호출하고, 특정 값을 반환하도록 의존성을 시뮬레이션할 수 있다.  

목과 스텁은 분명 차이가 있지만 특정 멤버 함수를 스텁하는데만 사용하고자 하더라도 목을 만들어야한다.

샘플 코드입니다.

아래는 PaymentResult settleInvoice() 함수를 인출 전에 계좌 잔액이 부족한지 확인할 수 있도록 수정한 코드입니다.

```java
  class PaymentManager {
      PaymentResult settleInvoice(BankAccount customerBankAccount, Invoice invoice) {

         // customerBankAccount.getBalance() 가 반환하는 값에 의존한다.
         if(customerBankAccount.getBalance().isLessThan(invoice.getBalance())) {
            return PaymentResult.insufficientFunds(invoice.getId());
         }
          customerBankAccount.debit(invoice.getBalance()); // 계좌로부터 청구서의 잔액만큼 인출하는 것을 테스트 하는 동작
          return PaymentResult.paid(invoice.getId());
      }
  }
```

위와 같이 새로운 기능으로 인해 테스트 케이스를 추가해야 하는 동작이 더 많아졌다.

- 잔액이 부족할 경우 PaymentResult 를 반환한다.
- 잔액이 부족한 경우 계좌로부터 인출이 되어서는 안 된다.
- 잔액이 충분할 때 계좌로부터 인출되어야 한다.

BankAccount 의 구현체를 사용하여 실제 은행계좌 잔액을 읽어오면 테스트 결과가 비결정적일 수 밖에 없다.
> 테스트 결과를 신뢰하기 어렵다.

외부로부터 테스트를 보호해야하는 상황이기 때문에 BankAccount.getBalance() 에 스텁을 사용하면된다.

테스트 코드입니다.

```java
  void testSettleInvoice_insufficientFundsCorrectResultReturned() {
      ... 생략
      BankAccout mockAccount = createMock(BankAccount); // 스텁만 필요하지만 BankAccount 의 목 객체 생성
      when(mockAccount.getBalance()) // 스텁을 통해서 
         .thenReturn(new MonetaryAmmount(9.99, Currency.USD)) // 목 객체의 getBalance() 는 항상 9.99를 반환

      PaymentManager result = new PaymentManager().settleInvoice(mockAccount,invoice); 

      assertThat(result.getStatus()).isEqualTo(INSUFFICIENT_FUNDS); // '잔액 부족' 이라는 결과가 반환되는지 확인
  } 
```

위와 같이 스텁을 사용 시 , 외부로부터 테스트를 보호하고 결과를 신뢰할 수 있습니다.

하지만 , 목 부분에서도 언급했듯이 목과 스텁에도 단점은 있다.


### 10.4.4 목과 스텁은 문제가 될 수 있다  

* 목과 스텁은 실제적이지 않은 테스트를 만들 수 있다.
settleInvoice() 함수 테스트를 위해 목 사용 시 , 송장 잔액이 5달러인 시나리오 테스트를 진행

- 고객이 환불이나 보상을 받을 경우 마이너스 잔액이 발생할 수 있다.

테스트 케이스를 복사하여 -5 달러로 설졍하면 되는 것이 아닌가?

```java
  void testSettleInvoice_accountDebited() {
      BankAccout mockAccount = createMock(BankAccount); // BankAccount 의 목 객체 생성
      MonetaryAmmount invoiceBalance = new MonetaryAmmount(-5.0, Currency.USD); // 마이너스 송장 잔액
      Invoice invoice = new Invoice(invoiceBalance, "id");
      
      new PaymentManager().settleInvoice(mockAccount,invoice); // mockAccount를 인수로 해서 호출

      verifyThat(mockAccount.debit)
         .wasCalledOnce()
         .withArguments(invoiceBalance); // mockAccount.debit() 함수가 음숫값으로 호출됨.
  }
```
실제 세계에서 음숫값으로 mockAccount.debit() 를 호출하는 것은 상정하기 어렵다.
(= 은행 계좌로부터 마이너스 금액을 인출하는 행위)

그렇다면 스텁은 ?

스텁을 사용하면 의존성 코드가 특정 값을 반환할 때 , 테스트의 대상코드가 기대한 대로 동작하는지 테스트한다.
돌려말하자면 의존성 코드가 실제로 반환하는 값인지에 대해서는 검증이 없다.

이렇듯 목과 스텁에 대한 사용을 둘러 싸고 의견이 많지만, 책의 필자는 최소한의 사용을 권장한다.

실제 의존성의 사용이 가능하다면 사용하거나 , 페이크 를 사용하는 것이 더 바람직하다고 한다.


### 10.4.5 페이크  

페이크(fake)는 클래스의 대체 구현체로 테스트에서 안전하게 수용한다.  

페이크는 실제 의존성의 공개 API를 정확하게 시뮬레이션하지만 구현은 일반적으로 단순한데, 외부 시스템과 통신 대신 페이크 내의 멤버 변수에 상태를 저장한다.  

페이크의 요점은 코드 계약이 실제 의존성과 동일하기 때문에 실제 클래스가 특정 입력을 받아들이지 않는다면 페이크도 마찬가지일 것이며,

실제 의존성에 대한 코드를 유지보수하는 팀이 일반적으로 페이크 코드도 유지보수해야 하는데, 실제 의존성에 대한 코드 계약이 변경되면 페이크의 코드 계약도 동일하게 변경되어야 하기 때문이다.  

샘플 코드 입니다.

```java
  class FakeBankAccount implements BankAccount { // BankAccount 인터페이스를 구현한다.

      private MonetaryAmount balance; // 멤버 변수를 통해서 은행의 백엔드 시스템과의 통신을 대체하여 상태를 추적한다.

      FakeBankAccount(MonetaryAmount startingBalance) {
         this.balacne = startingBalance;
      }

      /** debit() , credit() 함수가 마이너스 금액으로 호출되는 경우 예외를 발생시키도록 한다. -> 목과 스텁에서의 문제점 보안 
       *  실제 구현체와 동일한 방식으로 동작한다.  
       */
      @Override
      void debit(MonetaryAmount amount) {
         if(amonut.isNegative()) { 
            throw new ArgumentException("액수는 0보다 적을 수 없다."); // 액수가 음수일 경우 예외 처리
         } 
         balance = balacne.subtract(amount);  
      }

      @Override
      void credit(MonetaryAmount amount) {
         if(amonut.isNegative()) { 
            throw new ArgumentException("액수는 0보다 적을 수 없다."); // 액수가 음수일 경우 예외 처리
         } 
         balance = balacne.add(amount);  
      }

      @Override
      void transfer(MonetaryAmount amount) {
         balance.add(amount);
      }

      @Override
      MonetaryAmount getBalance() {
         return roundDownToNearest10(balance); // 잔액은 가장 가까운 10의 배수로 반내림 하여 반환한다.
      }
      /** 실제 구현체에서 구현하는 기능과 별개의 기능으로 테스트 환경에서 실제 잔액을 확인할 수 있게끔 추가 */
      MonetaryAmount getActualBalance() { 
         return balance;
      }
  }
```

위 페이크 객체를 통한 테스트 코드입니다.

```java
  void testSettleInvoice_negetiveInvoiceBalance() {

      FakeAccount fakeAccount = new FakeAccount(new MonetaryAmount(100.0, Currency.USE)); // 100 달러 잔액으로 초기화 되어 생성된 페이크 객체
      MonetaryAmmount invoiceBalance = new MonetaryAmmount(-5.0, Currency.USD); // 마이너스 송장 잔액
      Invoice invoice = new Invoice(invoiceBalance, "id");

      PaymentManager paymentManager = new PaymentManager().settleInvoice(fakeAccount,invoice); // fakeAccount 로 호출되는 테스트대상 코드
      
      assertThat(fakeAccount.getActualBalance()).isEqualTo(new MonetaryAmount(105.0, Currency.USE)); // 새로운 계좌 잔액이 105 달러인지 확인
  }
```

테스트 코드는 버그가 있으면 실패하고, 코드 작성자는 이를 인지하여 자신의 코드에 버그가 있음을 인지해야한다.

따라서 위 예제 코드의 테스트 케이스는 정확히 이러한 일을 해주기 때문에 유용하다고 볼 수 있다.


### 10.4.6 목에 대한 의견  

* 목 찬성론자: 개발자는 단위 테스트 코드에서 의존성을 실제로 사용하는 것을 피해야 하고 대신 목을 사용해야 한다고 주장한다.  
* 고전주의자: 목과 스텁은 최소한으로 사용되어야 하고 개발자는 테스트에서 의존성을 실제로 사용하는 것을 최우선으로 해야한다.  

목을 사용한 테스트는 상호작용을 하는 반면, 고전주의 방법을 사용한 테스트는 코드의 결과 상태와 의존성을 테스트하는 경향이 있다는 점이다.  

이러한 의미에서 목 접근법은 대상 코드를 어떻게 하는가를 확인하는 반면, 고전 주의 접근법은 코드를 실행하는 최종 결과가 무엇인지 확인하는 경향이 있다.  

## 10.5 테스트 철학으로부터 신중하게 선택하라  

책의 앞부분에서도 계속 나온 내용처럼 테스트에 대한 철학과 방법론의 내용처럼 이런 내용에 정답은 없다.  

스스로 판단하여 옳다고 생각하는 바를 실천할 자유가 있다.  

* 테스트 주도 개발(test-development, TDD): TDD는 실제 코드를 작성하기 전에 테스트 케이스를 먼저 작성하는 것을 지지한다.  

실제 코드는 테스트만 통과하도록 최소한으로 작성하고 이후에 구조를 개선하고 중복을 없애기 위해 리팩터링을 한다.  

* 행동 주도 개발(Behavior-driven devlopment, BDD): BDD는 사람마다 조금씩 다른 의미를 가질 수 있지만 <br/> 이 철학의 핵심은 사용자, 고객, 비즈니스의 관점에서 소프트웨어가 보야야 할 행동을 식별하는 데 집중하는 것이다.  

* 수용 테스트 주도 개발(Acceptance test-driven developnent ATDD): 고객의 관점에서 소프트웨어가 보여줘야 하는 동작을 식별하고 <br/>소프트웨어가 전체적으로 필요에 따라 작동하는지 검증하기 위해 자동화된 수락 테스트를 만드는 것을 수반한다.  
