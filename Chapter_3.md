# Chapter 3. 다른 개발자와 코드 계약

## 이 장에서 다루는 내용
- 다른 개발자들이 코드와 어떻게 상호작용하는지
- 코드 계약과 코드 계약의 세부 조항
- 세부 조항을 최소화하는 것이 어떻게 오용과 예측을 벗어나는 코드를 예방하는 데 도움이 되는지
- 세부 조항을 피할 수 없다면 체크와 어서션을 어떻게 사용할 수 있는지

## 3.1 자신의 코드와 다른 개발자의 코드
팀의 일원으로 코드를 작성한다고 생각해보자. 아래와 같은 상황이 발생한다.
- 내가 작성한 하위문제 해결 코드가 생각지 못한 완전히 다른 문제에서 재사용될 수 있다.
  >`자동차 경주 미션`에서 나는 `자동차의 전진 여부를 결정하는 숫자`를 만들기 위해 아래와 같은 클래스를 사용했다.
  ```java
  public class RandomNumberGenerator implements NumberGenerator {
  
      private final int minimum;
      private final int maximum;
      private final Random random = new Random();
  
      public RandomNumberGenerator(int minimum, int maximum) {
          this.minimum = minimum;
          this.maximum = maximum;
      }
  
      @Override
      public int generate() {
          return minimum + random.nextInt(maximum + 1);
      }
  }
  ```
  > 하지만 만약 지금과 같은 개발 환경이 아니라, 팀 개발 환경에서 누구나 이 클래스를 사용할 수 있는 상황이었다고 생각해보자.  
  `자동차의 전진`과는 관련 없는 부분을 구현하는 개발자가 랜덤 숫자를 생성하는 기능이 필요해 이 코드를 필요로 할 수도 있다.  
   그렇다면 이 클래스의 추상화 상태를 유지하는 데 유의해야 할 것이다. (자동차 관련 로직을 추가하지 않는 등)
   
  
- 요구 사항은 항상 변한다. 우선순위 변경, 새로운 기능, 새로운 기술환경  
  - 활발하고 바쁜 장소에 뭔가 꺠지기 쉬운 것이 있다면, 금방 망가질 것이다.
  - 마찬가지로 여러 개발자들이 활발하게 코드를 변경하더라도 코드의 품질이 유지되려면, 코드가 튼튼하고 사용하기 쉬워야 한다. (== 고품질의 코드)

따라서 코드를 작성할 때, 다음 세 절(3.1.1~3.1.3)에서 다루는 각 사항을 고려하는 것이 유용하다.

### 3.1.1 자신에게 분명하다고 해서 다른 사람에게도 분명한 것은 아니다
- 코드를 작성하는 당사자는 오랜 시간 문제에 대해 생각하기 때문에 자신의 로직에 익숙해진다.
- 하지만 작성한 코드로 다른 개발자와 상호작용하거나, 코드를 변경할 때에는 그 문제를 이해하고 생각할 시간이 코드 작성 당시만큼 충분하지 못하다.  
  (그렇다고 주석문을 많이 작성하는 게 좋다는 의미는 아니다! 이에 대해서는 이후에 다룬다.)
- 따라서 **코드를 이해하기 쉽고, 코드 자체로 설명이 되게 하는 것**이 좋다.

### 3.1.2 다른 개발자는 무의식 중에 여러분의 코드를 망가뜨릴 수 있다.
- 혼자서 작성한 코드이더라도 이는 **독립적으로 존재하지 않는다.**
- 코드에 대한 사전지식이 부족한 개발자가 의도치 않게 잘 실행되던 코드를 작동하지 않게 하거나 오용하는 방식으로 코드를 추가하거나 수정할 수 있다.

- 이를 방지하기 위한 방법   
  무언가 문제가 있을 때,  
    - 코드 컴파일이 중지되게 한다.
      > 해당 코드가 오용되었을 때 `Checked Exception` 예외를 발생시키라는 의미일까? (아니라면 어떤 방식을 말하는 걸까?)  
      만약 그렇다면 이는 좋은 방법일까?
      잘못된 코드를 배포할 일은 줄어들겠지만 그만큼 여러 단점들이 있을 것 같다.  
      [당신의 Checked Exception은 필요 없다](https://velog.io/@sangmin7648/%EB%8B%B9%EC%8B%A0%EC%9D%98-Checked-Exception%EC%9D%80-%ED%95%84%EC%9A%94-%EC%97%86%EB%8B%A4)
    - 테스트가 실패하도록 한다.
      > 이는 좋은 방법이라고 생각된다.  
      도메인 요구사항에 대해 꼼꼼하게 고려하여 단위 테스트를 작성할 수록 문제 발견이 빨랐기 때문이다.  
      반대로 단위 테스트를 소홀히 작성했을 때에는 문제 발견도 늦어졌고, 이전에 작성한 코드에 대해 파악하는 데 시간을 사용해야 했다.
      
### 3.1.3 시간이 지나면 자신의 코드를 기억하지 못한다.
- 자신의 코드를 다른 개발자가 읽거나 사용할 때 발생하는 문제점이 어느 순간 자기 자신에게도 적용된다.
- 1~2년 전에 작성한 코드를 다시 보는 일은 다른 사람이 작성한 코드를 보는 것과 크게 다르지 않다.
  > 이 내용을 읽고 좋은 코드에 대해 고민하지 않고 작성한 내 과거 코드를 찾아 보았다.  
  > 당시에는 나중에도 이해하기 위하여 열심히 주석을 달아놓았지만,  
  > 한 번에 너무 많은 일을 하는 메서드, 객체지향적이지 않은 설계로 인해 해당 코드의 작동 방식을 
  > 바로 파악할 수 없었다.

- 즉 배경지식이 없는 사람에게도 이해하기 쉽고, 버그가 쉽게 발생하지 않는 코드를 작성하는 것은 타인에 대한 호의일 뿐이 아니라 미래의 자신에게도 유익한 일이다.
# 3.3 코드 계약

개발자가 모든 조건을 알지 못한다면 코드 계약에 문제가 발생한다.
- `선결 조건`: 코드를 호출하기 전에 사실이어야 하는것.<br>
  시스템이 어떤 상태에 있어야 하는지, 코드에 어떤 입력을 공급해야 하는지
- `사후 조건`: 코드가 호출된 후에 사실이어야 하는것.<br>
  시스템이 새로운 상태에 놓이거나 반환되는 값과 같은 사항
- `불변 사항`: 코드 호출 전후 상태를 비교하여 변경되지 않아야 하는 사항

## 3.3.1 계약의 세부 사항

### 코드에서의 세부 사항

#### 계약의 명확한 부분
- `함수와 클래스 이름`: 호출 하는 쪽에서 이것을 모르면 사용할 수 없다.
- `인자 유형`: 호출하는 쪽에서 인자의 유형을 모르면 컴파일 조차 되지 않는다.
- `반환 유형`: 위와 같다.
- `검사 예외`(checked exception): 호출하는 코드가 이것을 처리하지 않으면 컴파일 되지 않는다.

#### 세부 조항
- `주석과 문서`: 호출 하는 쪽에서 이것을 모르면 사용할 수 없다.
- `비검사 예외`(unChecked exception): 주석문에 이 예외가 나열되어 있다면 이것은 세부조항 이다.

코드 계약에서 조건을 명확하게 하는 것이 세부 조항을 사용하는 것 보다 훨씬 좋다.<br>
세부 조항은 보통 잘 읽지 않는 경우가 많기 때문이다.

## 3.3.2 세부 조항에 너무 의존하지 말라

### 코드에서의 세부 사항

#### `세부조항이 많은` 안좋은 코드의 예시

```
public class UserSettings {
UserSettings(){}

    //이 함수를 사용해 설정이 올바르게 로드되기 전까지 어떤 함수도
    //호출되서는 안된다.
    //설정이 완료 되면 참을 반환한다.
    Boolean loadSettings(){}

    //이 함수는 다른 함수 호출 이전에 사용되어야 하지만
    //loadSettings() 함수 호출 이후에만 호출해야 한다.
    void init(){}

    //사용자가 선택한 UI의 색상을 반환한다.
    //선택된 색상이 없거나, 설정이 로드되지 않았거나, 초기화 되지 않은 상태면,
    // 널을 반환한다.
    Color? getUiColor(){}
}
```
이 클래스는 주석문 즉 세부조항을 자세히 보지 않으면 잘못 사용될 가능성이 큰 안좋은 코드이다.<br>
위 클래스의 함수들은 loadSettings -> init -> getUiColor 순서로 호출이 되어야만 제대로 작동이 된다.<br>
아래 코드는 위 클래스를 잘못 사용하여 오류가 발생한 예시이다.

```
void setUiColor(UserSettings userSettings){
        Color? chosenColor = user Sttings.getUiColor();
        if(chosenColor == null){
            ui.setColor(기본색상);
            return;
        }
        ui.setColor(chosenColor);
    }
```
만약 loadSettings이 제대로 이주어 지지 않은 상태로 setUiColor() 함수를 실행해도 문제없이 동작하게 된다.<br>
즉, 사용자 설정이 제대로 이루어지지 않은 상태에서도 setUiColor() 함수를 실행하게 되면<br>
null 값으로 받아서 기본 색상으로 초기화가 되는 것이다.

`정적 팩토리 함수를 사용해 초기화가 완전히 이루어진 인스턴스를 얻는것만 가능하도록 수정하기`

```
public class UserSettings {
    private UserSettings(){}

    static UserSettings? create(){
        UserSettings settings = new UserSettings();
        if(!settings.loadSettings()){
            return null;
        }
        settings.init();
        return settings;
    }
    private Boolean loadSettings(){}
    private void init(){}

    //사용자가 선택한 UI의 색상을 반환한다.
    //색상이 선택되지 않은 경우
    // 널을 반환한다.
    Color? getUiColor(){}
}
```
- 위 추가된 정적 팩토리 함수는 유효한 상태에 있는 클래스의 인스턴스만 반환한다.
- create() 함수를 사용하도록 강제하기 위해 생성자는 private으로 설정한다.
- 클래스가 잘 초기회 되어야만 사용 가능하게 강제하였기 때문에 getUiColor() 함수가 null 값을 반환하면<br>
  이는 사용자가 색상을 선택하지 않았다는 의미로만 해석할 수 있게 된다.

`가변성`
- 객체를 만든 후 객체의 상태를 수정할 수 있음

`불변적`
- 객체를 만든 후 객체의 상태를 수정할 수 없음

<br>

# 3. 다른 개발자와 코드 계약

# 3.4 체크 및 어서션

런타임 검사는 컴파일 타임 확인만큼 강력하진 않다.

`코드 계약` 위반이 런타임에 발생하는 문제에 대한 검사나 사용자에 의존하기 때문이다.

> 자주 사용하는 `validateX()` 처럼
실행 중에 잘못된 상황을 검사하는 경우나, 사용자와의 상호작용으로 나타나는 문제들을 얘기해요.
> 

처음부터 `코드 계약` 위반을 논리적으로 막는 컴파일 타임 확인과는 대조적이다.

그 외에도 컴파일러로 계약을 강제할 수 없는 상황이 있는데, 아예 검사하지 않는 것보다 런타임 검사라도 하는 것이 낫다.

# 3.4.1 체크

## 목적

`코드 계약` 조건을 확인하기 위해 사용

- 입력 매개 변수에 대한 제약 조건
- 수행해야 할 설정에 대한 제약

등을 확인하기 위한 로직.

`체크`는 `실패` 를 유발하는 오류를 생성해 놓치고 넘어가지 못하게 한다.

> 앞서 말한 `validateX()`를 생각하면 좋을 것 같습니다.
> 

> 체크가 `failing fast` 와 관련있다고 얘기하는데, 다음 장에서 얘기한다고 합니다 :)
> 

## 전기 스쿠터 예시

- 스쿠터 펌웨어에 안전장치를 추가한다.
- 운전자가 시속 30마일로 달리면 스쿠터가 완전 정지되고, 다시 사용하기 위해서는 재부팅이 필요하다.
- 운전 중에 위험할 수도 있지만, 모터를 손상시키고 과속 딱지를 끊는 것보다는 안전 장치가 작동하는 편이 나을 수 있다.
- 또, 이것보다는 속도 제한 장치를 사용하는 것이 나쁜 상황을 막으므로 최상의 방법이다.

> 이런 문제는 빨리 발견할 수 있으므로 빨리 조치할 수 있다는 얘기인 것 같네요.
`체크` 가 있는 편이 확인하기 어려운 것보다 더 낫다는 이야기 입니다.
책이 구글 번역기 돌린 것처럼 이해하기 좀 어렵게 쓰여있습니다..
> 

## 분류

### 전제 조건 검사

EX) 인수가 올바른지, 초기화가 수행되었는지, 코드 실행 전 시스템이 유효한 상태인지 확인한다.

### 사후 상태 검사

EX) 반환 값이 올바른지, 코드 실행 후 시스템이 유효한 상태인지 확인한다.

## `UserSettings` 예시

앞선 장에서 `UserSettings` 클래스가 잘못 설정되는 것을 처음부터 막아 오류를 줄일 수 있었다.

또 다른 방법은 **전제 조건 검사**를 사용하는 것이다.

![https://user-images.githubusercontent.com/39221443/222220393-dc0277c2-8614-4dd2-852c-a0052cfb0e21.png](https://user-images.githubusercontent.com/39221443/222220393-dc0277c2-8614-4dd2-852c-a0052cfb0e21.png)

버그가 아무도 모르게 발생하는 것을 방지한다.

그러나, 오용을 아예 불가능하게 만든것보다는 이상적이지 않다.

> 컴파일 단계에서 막은 것보다는 이상적이지 않다는 뜻이라고 생각합니다.
> 

## `체크` 의 효과

고객에게 배포되거나 실제 프로덕션에서 서비스되기 전에 개발 단계나 테스트 단계에서 발견되고, 수정될 수 있다.

- 알아차리지 못한 채로 유효하지 못한 상태로 들어가 이상한 버그가 발견되는 것보다는 낫다.

그러나, `체크`의 효과가 항상 보장되지는 않는다.

> 즉, 예외에 걸리지 않는 상황이 있을 수 있다는 뜻인 것 같습니다.
> 
- 테스트하기 불분명한 상황에서만 조건이 위반된다면, 코드가 배포되고 사용자가 쓰기 전까지 버그가 노출되지 않을 수 있다.
- 체크가 잘 작동해도 알지 못할 위험이 있다.
    - 시스템이 아예 멈추는 것을 막기 위해 ‘로깅’을 해두었는데, 개발자들이 잘 확인하지 않는 경우
    - 이 경우는 팀의 실행 지침이나, 예외 처리 지침에 문제가 있다.
    - 꽤 자주 있는 경우이다.

## 결론

경우에 따라 `코드 계약` 에서 세부 조항을 피할 수 없으면, 계약이 준수되는지 확인하기 위해 체크를 추가하는 편이 좋다.

하지만 가능하다면 세부 조항 자체를 피하는 것이 바람직하다.

코드에 체크가 많다면 세부 조항을 없애는 것을 고려해봐야 한다는 신호일지 모른다.


# 3.4.2 어서션

많은 언어에서 `어서션`을 언어 차원에서 지원한다.

## `체크`와 비교

### 유사점

`어서션`은 `코드 계약` 을 준수하도록 강제하기 위한 방법이라는 점에서 **체크와 유사**하다.

코드가 개발 모드에서 컴파일 되거나, 테스트를 실행할 때 체크와 거의 같은 방식으로 동작한다.

- 조건이 위반되면 오류가 명백하게 보이거나, 예외가 발생한다.

### 차이점

배포를 위해 빌드할 때 보통 **컴파일에서 제외**된다

- 이유
    - 성능 향상
        - 조건 위반 확인에는 CPU 사이클이 필요하다.
        - `어서션`이 많으면, 소프트웨어의 전반적 성능이 현저히 저하될 수 있다.
    - 코드 오류 발생률 감소
        - `어서션`을 쓸 유효한 이유인지 아닌지는 프로그램에 따라 다르다.
        - 버그가 눈에 띄지 않을 가능성이 증가하지만, **고가용성**이 더 중요하다면, 적절할 수 있다.
            
            > [고가용성](https://ko.wikipedia.org/wiki/%EA%B3%A0%EA%B0%80%EC%9A%A9%EC%84%B1) - HA, High Availability
            서버나 소프트웨어가 언제든 접근 가능한 수준으로 다운 타임이 적은 성질을 의미해요.
            은행 서버나 소프트웨어는 고가용성을 갖춰야겠죠?
            > 

배포를 위한 빌드에서도 어서션을 쓸 수 있는 방법이 있고, 많은 개발팀이 이렇게 한다.

이 경우에는 `체크`와 비슷하며, 어떤 종류의 오류나 예외를 발생시키는지가 조금 다를 뿐이다.

## `UserSettings` 예시

![https://user-images.githubusercontent.com/39221443/222226673-21c6b99e-0068-42bc-8db4-f2f78e27819e.png](https://user-images.githubusercontent.com/39221443/222226673-21c6b99e-0068-42bc-8db4-f2f78e27819e.png)

`체크` 에 대해 언급했던 사항은 `어서션` 에도 해당된다.

- `코드 계약`에 **세부 조항**이 있을 때 `어서션` 을 사용하면 좋다. 하지만, 애초에 **세부 조항**을 피하는 것이 더 바람직하다.
    
    > **세부 조항**은 “위치는 100 이상을 넘을 수 없다” 같은 제약 조건을 이야기 하는 것 같아요.
    이런 제약 조건은 꼭 필요하지 않다면 없는게 CPU 자원을 아끼고, 소프트웨어의 유연성도 높일 수 있겠죠?
    > 

# `3.4.1`, `3.4.2` 요약

- 코드를 작성할 때 일종의 `코드 계약` 이 항상 만들어진다.
    - 명백한 항목이나, **세부 조항**과 같은 내용이 포함 될 수 잇따.
- `코드 계약` 의 **세부 조항**은 다른 개발자가 계약을 준수하도록 하기 위한 방법이지만, 신뢰할만한 방법은 아니다.
    - 더 나은 접근법은 명백한 항목으로 계약의 내용을 전달하는 것이다.
- 일반적으로 **컴파일러**를 사용하여 계약을 확인하는 것이 가장 신뢰할 수 있는 방법이다.
    - 이것이 가능하지 않을 때, `체크`나 `어서션`을 사용해 런타임에 계약을 확인할 수 있다.

      
